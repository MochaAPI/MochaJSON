"use strict";(globalThis.webpackChunkmochaapi_client_docs=globalThis.webpackChunkmochaapi_client_docs||[]).push([[663],{205:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>u,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>s});const i=JSON.parse('{"id":"examples/multiple-clients","title":"Multiple Clients Patterns","description":"Managing multiple API clients with different configurations in MochaJSON v1.0.0.","source":"@site/docs/examples/multiple-clients.md","sourceDirName":"examples","slug":"/examples/multiple-clients","permalink":"/MochaJSON/examples/multiple-clients","draft":false,"unlisted":false,"editUrl":"https://github.com/MochaAPI/MochaJSON/tree/main/docs/docs/examples/multiple-clients.md","tags":[],"version":"current","frontMatter":{"title":"Multiple Clients Patterns","description":"Managing multiple API clients with different configurations in MochaJSON v1.0.0.","keywords":["multiple clients","different configurations","client management","stateless design"]}}');var r=t(4848),l=t(8453);const a={title:"Multiple Clients Patterns",description:"Managing multiple API clients with different configurations in MochaJSON v1.0.0.",keywords:["multiple clients","different configurations","client management","stateless design"]},o="Multiple Clients Patterns",u={},s=[{value:"Basic Multiple Clients",id:"basic-multiple-clients",level:2},{value:"Client Manager Pattern",id:"client-manager-pattern",level:2},{value:"Spring Boot Configuration",id:"spring-boot-configuration",level:2},{value:"Environment-Specific Clients",id:"environment-specific-clients",level:2},{value:"Kotlin Multiple Clients",id:"kotlin-multiple-clients",level:2},{value:"Kotlin Client Manager",id:"kotlin-client-manager",level:3},{value:"Kotlin Object Pattern",id:"kotlin-object-pattern",level:3},{value:"Testing Multiple Clients",id:"testing-multiple-clients",level:2},{value:"Key Benefits",id:"key-benefits",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"multiple-clients-patterns",children:"Multiple Clients Patterns"})}),"\n",(0,r.jsx)(e.p,{children:"Managing multiple API clients with different configurations in MochaJSON v1.0.0."}),"\n",(0,r.jsx)(e.h2,{id:"basic-multiple-clients",children:"Basic Multiple Clients"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'import io.mochaapi.client.*;\nimport java.time.Duration;\n\npublic class MultipleClientsExample {\n    public static void main(String[] args) {\n        try {\n            // Different clients for different APIs\n            ApiClient githubClient = new ApiClient.Builder()\n                .connectTimeout(Duration.ofSeconds(10))\n                .requestInterceptor(req -> {\n                    req.header("Authorization", "Bearer " + getGithubToken());\n                    req.header("Accept", "application/vnd.github.v3+json");\n                    return req;\n                })\n                .build();\n            \n            ApiClient internalClient = new ApiClient.Builder()\n                .allowLocalhost(true)\n                .connectTimeout(Duration.ofSeconds(5))\n                .requestInterceptor(req -> {\n                    req.header("Authorization", "Bearer " + getInternalToken());\n                    return req;\n                })\n                .build();\n            \n            ApiClient externalClient = new ApiClient.Builder()\n                .connectTimeout(Duration.ofSeconds(30))\n                .allowLocalhost(false)  // Production-safe\n                .build();\n            \n            // Use them independently\n            Map<String, Object> githubUser = githubClient.get("https://api.github.com/user")\n                .execute()\n                .toMap();\n            \n            Map<String, Object> internalData = internalClient.get("http://localhost:8080/api/data")\n                .execute()\n                .toMap();\n            \n            Map<String, Object> externalData = externalClient.get("https://api.external.com/data")\n                .execute()\n                .toMap();\n            \n            System.out.println("GitHub user: " + githubUser.get("login"));\n            System.out.println("Internal data: " + internalData.get("value"));\n            System.out.println("External data: " + externalData.get("value"));\n            \n        } catch (Exception e) {\n            System.err.println("Error: " + e.getMessage());\n        }\n    }\n    \n    private static String getGithubToken() {\n        return System.getenv("GITHUB_TOKEN");\n    }\n    \n    private static String getInternalToken() {\n        return System.getenv("INTERNAL_TOKEN");\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"client-manager-pattern",children:"Client Manager Pattern"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'import io.mochaapi.client.*;\nimport java.time.Duration;\nimport java.util.concurrent.CompletableFuture;\n\npublic class ApiClientManager {\n    private final ApiClient githubClient;\n    private final ApiClient internalClient;\n    private final ApiClient externalClient;\n    \n    public ApiClientManager() {\n        this.githubClient = createGithubClient();\n        this.internalClient = createInternalClient();\n        this.externalClient = createExternalClient();\n    }\n    \n    private ApiClient createGithubClient() {\n        return new ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(10))\n            .requestInterceptor(req -> {\n                req.header("Authorization", "Bearer " + getGithubToken());\n                req.header("Accept", "application/vnd.github.v3+json");\n                return req;\n            })\n            .build();\n    }\n    \n    private ApiClient createInternalClient() {\n        return new ApiClient.Builder()\n            .allowLocalhost(true)\n            .connectTimeout(Duration.ofSeconds(5))\n            .requestInterceptor(req -> {\n                req.header("Authorization", "Bearer " + getInternalToken());\n                return req;\n            })\n            .build();\n    }\n    \n    private ApiClient createExternalClient() {\n        return new ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(30))\n            .allowLocalhost(false)\n            .build();\n    }\n    \n    public CompletableFuture<Map<String, Object>> getGithubUser() {\n        return githubClient.get("https://api.github.com/user")\n            .executeAsync()\n            .thenApply(response -> response.toMap());\n    }\n    \n    public CompletableFuture<Map<String, Object>> getInternalData(String endpoint) {\n        return internalClient.get("http://localhost:8080/api/" + endpoint)\n            .executeAsync()\n            .thenApply(response -> response.toMap());\n    }\n    \n    public CompletableFuture<Map<String, Object>> getExternalData(String endpoint) {\n        return externalClient.get("https://api.external.com/" + endpoint)\n            .executeAsync()\n            .thenApply(response -> response.toMap());\n    }\n    \n    // Concurrent requests\n    public CompletableFuture<Map<String, Object>> getAllData() {\n        CompletableFuture<Map<String, Object>> githubFuture = getGithubUser();\n        CompletableFuture<Map<String, Object>> internalFuture = getInternalData("data");\n        CompletableFuture<Map<String, Object>> externalFuture = getExternalData("data");\n        \n        return CompletableFuture.allOf(githubFuture, internalFuture, externalFuture)\n            .thenApply(v -> {\n                Map<String, Object> result = new HashMap<>();\n                result.put("github", githubFuture.join());\n                result.put("internal", internalFuture.join());\n                result.put("external", externalFuture.join());\n                return result;\n            });\n    }\n    \n    private String getGithubToken() {\n        return System.getenv("GITHUB_TOKEN");\n    }\n    \n    private String getInternalToken() {\n        return System.getenv("INTERNAL_TOKEN");\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"spring-boot-configuration",children:"Spring Boot Configuration"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'import io.mochaapi.client.*;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport java.time.Duration;\n\n@Configuration\npublic class ApiClientConfig {\n    \n    @Value("${github.token}")\n    private String githubToken;\n    \n    @Value("${internal.token}")\n    private String internalToken;\n    \n    @Value("${external.api.key}")\n    private String externalApiKey;\n    \n    @Bean\n    public ApiClient githubClient() {\n        return new ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(10))\n            .requestInterceptor(req -> {\n                req.header("Authorization", "Bearer " + githubToken);\n                req.header("Accept", "application/vnd.github.v3+json");\n                return req;\n            })\n            .build();\n    }\n    \n    @Bean\n    public ApiClient internalClient() {\n        return new ApiClient.Builder()\n            .allowLocalhost(true)\n            .connectTimeout(Duration.ofSeconds(5))\n            .requestInterceptor(req -> {\n                req.header("Authorization", "Bearer " + internalToken);\n                return req;\n            })\n            .build();\n    }\n    \n    @Bean\n    public ApiClient externalClient() {\n        return new ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(30))\n            .allowLocalhost(false)\n            .requestInterceptor(req -> {\n                req.header("X-API-Key", externalApiKey);\n                return req;\n            })\n            .build();\n    }\n}\n\n@Service\npublic class DataService {\n    private final ApiClient githubClient;\n    private final ApiClient internalClient;\n    private final ApiClient externalClient;\n    \n    public DataService(ApiClient githubClient, \n                      ApiClient internalClient, \n                      ApiClient externalClient) {\n        this.githubClient = githubClient;\n        this.internalClient = internalClient;\n        this.externalClient = externalClient;\n    }\n    \n    public Map<String, Object> getGithubUser() {\n        return githubClient.get("https://api.github.com/user")\n            .execute()\n            .toMap();\n    }\n    \n    public Map<String, Object> getInternalData(String endpoint) {\n        return internalClient.get("http://localhost:8080/api/" + endpoint)\n            .execute()\n            .toMap();\n    }\n    \n    public Map<String, Object> getExternalData(String endpoint) {\n        return externalClient.get("https://api.external.com/" + endpoint)\n            .execute()\n            .toMap();\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"environment-specific-clients",children:"Environment-Specific Clients"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'import io.mochaapi.client.*;\nimport java.time.Duration;\n\npublic class EnvironmentSpecificClients {\n    \n    public static ApiClient createClient(Environment environment) {\n        switch (environment) {\n            case PRODUCTION:\n                return createProductionClient();\n            case STAGING:\n                return createStagingClient();\n            case DEVELOPMENT:\n                return createDevelopmentClient();\n            case TEST:\n                return createTestClient();\n            default:\n                throw new IllegalArgumentException("Unknown environment: " + environment);\n        }\n    }\n    \n    private static ApiClient createProductionClient() {\n        return new ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(15))\n            .readTimeout(Duration.ofSeconds(60))\n            .enableRetry()\n            .allowLocalhost(false)  // Production-safe\n            .requestInterceptor(req -> {\n                req.header("Authorization", "Bearer " + getProductionToken());\n                req.header("User-Agent", "MyApp/1.0");\n                return req;\n            })\n            .build();\n    }\n    \n    private static ApiClient createStagingClient() {\n        return new ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(10))\n            .readTimeout(Duration.ofSeconds(30))\n            .enableRetry()\n            .allowLocalhost(false)  // Staging-safe\n            .requestInterceptor(req -> {\n                req.header("Authorization", "Bearer " + getStagingToken());\n                req.header("User-Agent", "MyApp/1.0-staging");\n                return req;\n            })\n            .build();\n    }\n    \n    private static ApiClient createDevelopmentClient() {\n        return new ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(5))\n            .readTimeout(Duration.ofSeconds(15))\n            .enableRetry()\n            .allowLocalhost(true)   // Development-friendly\n            .enableLogging()\n            .requestInterceptor(req -> {\n                req.header("Authorization", "Bearer " + getDevelopmentToken());\n                req.header("User-Agent", "MyApp/1.0-dev");\n                return req;\n            })\n            .build();\n    }\n    \n    private static ApiClient createTestClient() {\n        return new ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(1))\n            .readTimeout(Duration.ofSeconds(5))\n            .allowLocalhost(true)\n            .build();\n    }\n    \n    private static String getProductionToken() {\n        return System.getenv("PRODUCTION_TOKEN");\n    }\n    \n    private static String getStagingToken() {\n        return System.getenv("STAGING_TOKEN");\n    }\n    \n    private static String getDevelopmentToken() {\n        return System.getenv("DEVELOPMENT_TOKEN");\n    }\n    \n    public enum Environment {\n        PRODUCTION, STAGING, DEVELOPMENT, TEST\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"kotlin-multiple-clients",children:"Kotlin Multiple Clients"}),"\n",(0,r.jsx)(e.h3,{id:"kotlin-client-manager",children:"Kotlin Client Manager"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:'import io.mochaapi.client.*\nimport java.time.Duration\n\nclass ApiClientManager {\n    val githubClient by lazy {\n        ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(10))\n            .requestInterceptor { req ->\n                req.header("Authorization", "Bearer ${getGithubToken()}")\n                req.header("Accept", "application/vnd.github.v3+json")\n                req\n            }\n            .build()\n    }\n    \n    val internalClient by lazy {\n        ApiClient.Builder()\n            .allowLocalhost(true)\n            .connectTimeout(Duration.ofSeconds(5))\n            .requestInterceptor { req ->\n                req.header("Authorization", "Bearer ${getInternalToken()}")\n                req\n            }\n            .build()\n    }\n    \n    val externalClient by lazy {\n        ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(30))\n            .allowLocalhost(false)\n            .build()\n    }\n    \n    suspend fun getGithubUser(): Map<String, Any> = withContext(Dispatchers.IO) {\n        githubClient.get("https://api.github.com/user")\n            .execute()\n            .toMap()\n    }\n    \n    suspend fun getInternalData(endpoint: String): Map<String, Any> = withContext(Dispatchers.IO) {\n        internalClient.get("http://localhost:8080/api/$endpoint")\n            .execute()\n            .toMap()\n    }\n    \n    suspend fun getExternalData(endpoint: String): Map<String, Any> = withContext(Dispatchers.IO) {\n        externalClient.get("https://api.external.com/$endpoint")\n            .execute()\n            .toMap()\n    }\n    \n    suspend fun getAllData(): Map<String, Any> = coroutineScope {\n        val githubDeferred = async { getGithubUser() }\n        val internalDeferred = async { getInternalData("data") }\n        val externalDeferred = async { getExternalData("data") }\n        \n        mapOf(\n            "github" to githubDeferred.await(),\n            "internal" to internalDeferred.await(),\n            "external" to externalDeferred.await()\n        )\n    }\n    \n    private fun getGithubToken(): String = System.getenv("GITHUB_TOKEN") ?: ""\n    private fun getInternalToken(): String = System.getenv("INTERNAL_TOKEN") ?: ""\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"kotlin-object-pattern",children:"Kotlin Object Pattern"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-kotlin",children:'import io.mochaapi.client.*\nimport java.time.Duration\n\nobject ApiClients {\n    val github by lazy {\n        ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(10))\n            .requestInterceptor { req ->\n                req.header("Authorization", "Bearer ${getGithubToken()}")\n                req.header("Accept", "application/vnd.github.v3+json")\n                req\n            }\n            .build()\n    }\n    \n    val internal by lazy {\n        ApiClient.Builder()\n            .allowLocalhost(true)\n            .connectTimeout(Duration.ofSeconds(5))\n            .requestInterceptor { req ->\n                req.header("Authorization", "Bearer ${getInternalToken()}")\n                req\n            }\n            .build()\n    }\n    \n    val external by lazy {\n        ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(30))\n            .allowLocalhost(false)\n            .build()\n    }\n    \n    private fun getGithubToken(): String = System.getenv("GITHUB_TOKEN") ?: ""\n    private fun getInternalToken(): String = System.getenv("INTERNAL_TOKEN") ?: ""\n}\n\n// Usage\nfun main() = runBlocking {\n    try {\n        val githubUser = ApiClients.github.get("https://api.github.com/user")\n            .execute()\n            .toMap()\n        \n        val internalData = ApiClients.internal.get("http://localhost:8080/api/data")\n            .execute()\n            .toMap()\n        \n        val externalData = ApiClients.external.get("https://api.external.com/data")\n            .execute()\n            .toMap()\n        \n        println("GitHub user: ${githubUser["login"]}")\n        println("Internal data: ${internalData["value"]}")\n        println("External data: ${externalData["value"]}")\n        \n    } catch (e: Exception) {\n        println("Error: ${e.message}")\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"testing-multiple-clients",children:"Testing Multiple Clients"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:'import io.mochaapi.client.*;\nimport java.time.Duration;\n\npublic class MultipleClientsTest {\n    \n    @Test\n    public void testMultipleClients() {\n        // Create test clients\n        ApiClient testClient1 = new ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(1))\n            .allowLocalhost(true)\n            .build();\n        \n        ApiClient testClient2 = new ApiClient.Builder()\n            .connectTimeout(Duration.ofSeconds(1))\n            .allowLocalhost(true)\n            .build();\n        \n        // Test that they\'re independent\n        Map<String, Object> data1 = testClient1.get("http://localhost:8080/api/data1")\n            .execute()\n            .toMap();\n        \n        Map<String, Object> data2 = testClient2.get("http://localhost:8080/api/data2")\n            .execute()\n            .toMap();\n        \n        assertNotNull(data1);\n        assertNotNull(data2);\n        // Clients are independent - no conflicts\n    }\n    \n    @Test\n    public void testConcurrentClients() throws Exception {\n        ApiClient client1 = new ApiClient.Builder().build();\n        ApiClient client2 = new ApiClient.Builder().build();\n        \n        CompletableFuture<Map<String, Object>> future1 = client1.get("http://localhost:8080/api/data1")\n            .executeAsync()\n            .thenApply(response -> response.toMap());\n        \n        CompletableFuture<Map<String, Object>> future2 = client2.get("http://localhost:8080/api/data2")\n            .executeAsync()\n            .thenApply(response -> response.toMap());\n        \n        Map<String, Object> result1 = future1.get();\n        Map<String, Object> result2 = future2.get();\n        \n        assertNotNull(result1);\n        assertNotNull(result2);\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Independent Configuration"})," - Each client has its own settings"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"No Conflicts"})," - Clients don't interfere with each other"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Thread Safety"})," - Multiple clients can be used concurrently"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Easy Testing"})," - Each client can be tested independently"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Flexible Architecture"})," - Different clients for different APIs"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Environment Support"})," - Easy to create environment-specific clients"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Dependency Injection"})," - Works well with Spring Boot and other frameworks"]}),"\n",(0,r.jsxs)(e.li,{children:["\u2705 ",(0,r.jsx)(e.strong,{children:"Resource Management"})," - No cleanup needed - clients are stateless"]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>o});var i=t(6540);const r={},l=i.createContext(r);function a(n){const e=i.useContext(l);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),i.createElement(l.Provider,{value:e},n.children)}}}]);